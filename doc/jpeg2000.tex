Part 1 of the \href{http://www.jpeg.org/jpeg2000/}{JPEG2000} standard describes 
a core compression system that is based on the dyadic 
\href{http://en.wikipedia.org/wiki/Discrete_wavelet_transform}
{DWT (Discrete Wavelet Transform)}
and the 
EBCOT (Embedded Block Coding with Optimal Truncation). Some features of this 
compression system are high compression ratios, error-resilience, lossless 
and lossy compression, random access to the compressed stream, resolution and 
quality scalability, and support for multiple components. 
These characteristics make it ideal for the coding and retrieving of 
large remote images.

\subsection{Data partitions}

The JPEG2000 standard defines a wide variety of partitions
for the image data, with the aim of exploiting at the maximum the
offered scalability. All of these partitions
allow an efficient manipulation of the image, or a part of it. Fig. 
\ref{fig:partitions} shows a graphical example of the main partitions.

\begin{figure}[!b]
  \begin{center}
    \resizebox{0.95\textwidth}{!}{\input{../partition}}
  \end{center}
  \caption{Data partition defined by the JPEG2000 standard.}
  \label{fig:partitions}
\end{figure}

In order to understand the concept of each partition defined
in the JPEG2000 standard, it is necessary to clarify the concept
of canvas. The canvas is a bidimensional drawing zone where
all the partitions are mapped to form the related image.
Hereinafter, all the used coordinates are in relation to 
a canvas, which size, width ($I_{2}$) and height ($I_{1}$), corresponds to
the total size of the associated image. Each partition is 
located and mapped over the canvas in a specific way.
An image is composed by one or more components. In the most
of the cases the images have only three components: red, green
and blue (RGB), with a size equals to the canvas.

The JPEG2000 standard allows to divide an image into smaller 
rectangular regions called tiles. Each tile is compressed 
independently in relation to the rest, hence the compression
parameters can be different among them. By default there is
always one tile as minimum, which equals to the whole image.

One of the possible applications of the tile partitioning is its use
with images that contain different elements and visually separated,
like text, graphics or photographic materials. When this does not
occur, and the images are continuous and homogeneous, the tiling
is not recommended because it produces artifacts in the borders of
the tiles, causing a mosaic effect. Moreover, the size of a
compressed image is larger when the tiles are used.

The DWT transform and all the quantification/coding stages
are applied independently to each tile-component. A tile-component,
of a tile $t$ and a component $c$, is defined by a bidimensional
zone limited by $t$ taking into account the zone occupied by
$c$. This means that, if an
image has only one tile, with three color components, there are
three tile-components, which are compressed independently.

For each tile-component, identified by the tile $t$ and the component
$c$, there are a total of $D_{t,c} + 1$
resolutions, where $D_{t,c}$ is the number
of DWT stages applied. The $r$-nth resolution level of a compressed
tile-component is obtained after applying $r$ times the inverse DWT
transform. The
$r$ value is in the range of $0 \leq r \leq D_{t,c}$. 

Each tile-component, after being applied the DWT, is 
divided into code-blocks, that are coded independently. 
In each resolution $r$ of each tile-component $(t,c)$, the
code-blocks are grouped in precincts. This partition is
defined by the height, $P_{1}^{t,c,r}$,
and the width, $P_{2}^{t,c,r}$,
of each precinct. The number of precincts in vertical, 
$N_{1}^{P,t,c,r}$, 
as well as in horizontal, $N_{2}^{P,t,c,r}$ are given by
the following expression:

\begin{equation*}
N_{i}^{P,t,c,r} = \left\lceil \frac{I_{i}}{2^{D_{t,c}-r}P_{i}^{t,c,r}} \right\rceil
\end{equation*}

Code-blocks refer to the wavelet coefficients generated by the DWT
transform, thus rectangular regions within the wavelet
domain. However, precincts refer to rectangular regions within the
image domain. The spatial scalability offered by the standard is
carried out with the precincts.  

The packet is the fundamental unit for the organization
of the compressed bit-stream of an image. Each precinct contributes
to the bit-stream as many packets as quality layers there are. The
compressed data of each code-block is divided in different segments
called quality layers. All the code-blocks of all the precincts
of the same tile are divided into the same number of quality layers,
although the length of the quality layers between code-blocks can be
different (the length can be even zero). For a certain layer $l$,
the set of all the layer $l$ of all the code-blocks related to a
precinct form a packet.

In order to decode a certain region of an image it is necessary
decode all the packets related to that region. In the server code,
the class \hyperlink{classjpip_1_1WOIComposer}{jpip::WOIComposer} allows to know,
for a given region of interest, hereinafter called WOI (Window
Of Interest), all the required packets to decode it. 

A packet $\zeta_{t,c,r,p,l}$ 
is identified by the tile $t$, the
component $c$, the resolution $r$, the precinct $p$ (in precinct
coordinates)
and the quality layer $l$. In the server code, the class
\hyperlink{classjpeg2000_1_1Packet}{jpeg2000::Packet} is used to
identify a packet.

\subsection{Code-stream organization}

Part 1 of the JPEG2000 standard defines a basic structure for
organizing the image compressed data into code-streams. A code-stream
includes all the packets generated by a compression process of an image
plus a set of markers, that are used for signaling certain parts, as
well as for including information necessary for the decompression. 

The code-stream is itself a simple file format for JPEG2000 image.
Any standard decompressor must be able to understand a code-stream
stored within a file. This basic format is also called raw, and
its most used extension is ``.J2C''.

The markers have an unique identifier, that consists of an unsigned
integer of $16$ bits. These markers can be found alone, that is,
only the identifier, or accompanied by additional information,
receiving in this case the name of marker segment.

The marker segment has, after the identifier, another unsigned
integer of $16$ bits with the length of the included data, including
as well the two bytes of this integer, but without counting the
two bytes of the identifier.

The code-stream always begins with the SOC (Start Of Code-stream)
marker, which does not include any additional information. 
After this marker a set of markers called ``main header'' begins.
After the SOC marker there is always a SIZ marker, with global 
information necessary for decompressing the data, e.g. the image
size, the tile size, the anchor point of the tiles, the number
of components, the sub-sampling factors, etc.

There are another two markers that are mandatory in the main header:
COD, with information related to the coding of the image, like the
number of layers, number of DWT stages, the size of the code-blocks,
the progression, etc.; and QCD, which contains the quantization
parameters. These two markers can be stored in any position within the
main header.

The rest of the code-stream, until the EOC (End Of Code-stream),
located just at the end of it, is organized as it is shown
in Fig. \ref{fig:code-stream}. For each image tile, there is
a set of data. This data is divided into one or more tile-parts.
Each tile-part is composed by a header and a set of packets.
The header of the first tile-part is the main header of the tile.
The header of each tile-part begins with the SOT (Start Of Tile)
marker and ends with the SOD (Start Of Data) marker, starting then
the related sequence of packets, according to the last COD or POC
marker. The main header ends when the first SOT is found.

\begin{figure}[!t]
  \begin{center}
    \resizebox{0.65\textwidth}{!}{\input{../codestream}}
  \end{center}
  \caption{Code-stream organization.}
  \label{fig:code-stream}
\end{figure}

In order to permit a random access to the data of a code-stream,
that by default is not feasible, JPEG2000 offers the possibility
of including the TLM, PLM and/or PLT markers. The TLM and PLM markers
are included within the main header, whilst the PLT marker goes
in the header of a tile or tile-part. The goal of the TLM marker
is to store the length of each tile-part that appear within the
code-stream. This length includes the header as well
as the set of packets, so for knowing where is the beginning of the
data it is necessary to analyze firstly the header. The PLM marker
stores the length of each packet of each tile-part of the code-stream.
Each packet of the code-stream has a certain length, that can
not be known a priori. Therefore including this marker facilitates
a random access of the packets. The PLT marker has the same function
as the PLM marker, but at the level of tile-part, thus it stores
the length of all the packets of the belonging tile-part. This
marker is commonly most used than PLM. 

The PLM and PLT markers produces an increase of the code-stream
length, although the way of coding the packet lengths helps to
avoid an excessive overhead: a length $L$ of a certain packet,
that can be represented with $B_{L}$ bits, is stored coded
with $\left \lceil \frac{B_{L}}{7} \right \rceil$ bytes. For a
length $L$ is generated a sequence of bytes where only the
less significant $7$ bits are used. The most significant
bit of each byte indicates if the belonging byte is ($1$) or
not ($0$) the last one of the sequence. This way of numeric
encoding is widely used in Part 9 of the standard, specially with
the JPIP protocol. With this protocol, to each variable sequence
of bytes that represents a number encoded in this way is called
VBAS (Variable Byte-Aligned Segment). The class
\hyperlink{classjpip_1_1DataBinWriter}{jpip::DataBinWriter}, within the server code,
contains methods to generate VBAS coded values.

\subsection{Progressions}
\label{sec:progresiones}

The packets generated by the JPEG2000 compression process
are neither independent nor self-contained. Having a certain packet,
it is not possible to figure out to which part of the related image
it belongs without additional information. The length of the packet
can not be determined before being decoded, and many packets can not
be decoded without decoding other packets before. This is why it is
necessary to include markers like TLM, PLT or PLM, previously
commented, in order to allow a random access without decoding.

The packets of each tile-part appear according the progression
specified by the last COD or POC marker read, before the
SOD marker. Part 1 of the JPEG2000 standard defines 5 possible kinds of
progressions for ordering the packets within a tile or tile-part.
Each progression is identified by means of a combination
of four letters: ``L'' for quality layer, ``R'' for resolution
level, ``C'' for component and ``P'' for precinct. Each letter identifies
the partition of the progression. Hence for the LRCP progression,
for example, the packets would be included as follows:\\
\\for each layer $l$\\
\hspace*{1cm} for each resolution $r$\\
\hspace*{2cm} for each component $c$\\
\hspace*{3cm} for each precinct $p$\\
\hspace*{4cm} include the packet $\zeta_{t,c,r,p,l}$\\

The different progressions allowed by the standard are: LRCP, RLCP,
RPCL, PCRL and CPRL. To choose a progression or another depends on 
the application to
develop, and how the packet must to be decoded. For example,
if the packets are going to be accessed randomly, but 
as minimum disk accesses as possible are required, RPCL would
be the ideal progression in this case. 
In the case of image transmission, the packets must also follow a
specific order or progression when they are transmitted. 
When an image is transmitted from a server to a client, the most
desired goal is to allow the client to be able to show reconstructions
of the image with a quality that is increased as the data is received.
The quality of the reconstruction must be always the maximum possible
according to the received data. Under this criteria, the LRCP progression
can be confirmed as the best one, and it is the progression used by
the class \hyperlink{classjpip_1_1WOIComposer}{jpip::WOIComposer}.

\subsection{File formats}

Although the code-stream is completely functional as a basic
file format, it does not allow to include additional information
that could be necessary in certain applications, e.g. meta-data,
copyright information, or color palettes. By means of the COM
marker auxiliary information can be included within a 
code-stream, but it is not classified nor organized in
a standard way.

Part 1 of the standard also defines a file format based on ``boxes'' that
allows to include, for example, in the same file, several code-streams
and diverse information correctly identified. These files usually have
the extension ``.JP2'', extension also used for calling this kind
of files.

The JP2 files are easily extensible. A basic structure of box is defined,
which can contains any kind of information. Each box is unequivocally 
classified by means of a $4$-bytes identifier. A file can contain
several boxes with the same identifier. The standard proposes an
initial set of boxes, that may be extended  according to specific
requirements. In fact, the JP2 format is the base of the rest of
formats and extensions defined in the rest of parts of the standard.

Each box has a header of $8$ bytes. The first $4$ bytes, $L$, form
an unsigned integer with the length in bytes of the content of the
next $4$ bytes, $T$, contain the identifier of the kind of box. This
identifier is commonly treated like a string of $4$ ASCII characters.
The value of $L$ includes the header, hence the real length of the
content of the box is $L - 8$. $L$ can have any value bigger or
equal to $8$, but also $1$ or $0$. If $L = 1$ the length of the
content of the box is coded as an unsigned integer of $8$ bytes, $X$,
located after $T$. In this case the header occupies $16$ bytes and
the length of the content is then $X - 16$. If $L = 0$ the
length of the box content is undefined, being possible only for the
last box of the image file.

Boxes can contain another boxes inside. It is possible to know
whether a box contains or not sub-boxes depending on the value of
$T$. If a box contains sub-boxes, it only can contain sub-boxes, 
so it can not combine sub-boxes with other data.

Within the server code, the class \hyperlink{classjpeg2000_1_1FileManager}
{jpeg2000::FileManager} contains all the necessary code to read and parse
JPEG2000 image files, from simple raw J2C files to complex JPX ones with
hyperlinks. When this class parses an image file, extract the associated
index information and stores it in an object of the class
\hyperlink{classjpeg2000_1_1ImageInfo}{jpeg2000::ImageInfo}.
           
